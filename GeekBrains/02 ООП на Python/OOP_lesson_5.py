# ООП на Python (урок № 1)
#В упражнении мы потренируемся в создании объектно-ориентированной среды и создадим приложение, проводящее лингвистический
# анализ. Следуйте алгоритму и выполняйте действия последовательно, чтобы получить полноценный класс:
#1. Создайте класс Word. (Вспомните, какое зарезервированное слово используется для создания класса).
#2. Добавьте свойства text (класс будет хранить слово) и part (часть речи, которой является слово. Например, существительное,
# прилагательное и т.п.). Для добавления свойств воспользуйтесь методом __init__.
#3. Создайте экземпляр класса Word, передав в качестве параметров любое слово и указав его часть речи.
#4. Создайте класс Sentence. (по аналогии с п. 1).
#5. Добавьте свойство content. (по аналогии с п. 2).
#Пояснение к дальнейшему коду: content будет хранить список целых чисел, например [0, 1]. Эти номера необходимы для выбора
# слов из заранее созданного массива, чтобы сформировать предложение.
#Пример массива:
#words = [["собака", "сущ"],
#         ["ела", "глаг"],
#         ["колбасу", "сущ"],
#         ["вечером", "нар"]]
#Если content == [0, 2], получим предложение вида «Собака колбасу».
#6. Создайте из массива (можете взять приведённый выше или придумать свой) список, каждый элемент которого является
# экземпляром класса Word. Примечание: список list (назовём его words) — отдельная переменная, не относящаяся к классам
# Word и Sentence.
#7. Добавьте в класс Sentence метод show, составляющий предложение. Метод должен перебирать числа из свойства content и
# подставлять соответствующие слова, которые хранятся в свойстве text экземпляров класса Word. Данные извлекаем из списка
# words, который получили на прошлом шаге. При соединении слов в предложение не забудьте добавить пробел между словами.
#8. Добавьте в класс Sentence метод show_parts, отображающий, какие части речи входят в предложение. По аналогии с п. 7
# перебирайте в цикле числа из свойства content и сохраняйте результат в отдельный список. Учтите, что части речи могут
# повторяться, но список не должен содержать дубликаты.


class Word:
    
    text = '' # не обязательно здесь писать это свойство
    part = '' # не обязательно здесь писать это свойство
    
    def __init__(self, text=text, part=part):
        self.text = text
        self.part = part



table = Word('стол', 'существительное')
print(type(table), table.text, table.part)
# Вывод вида - "<class '__main__.Word'> стол существительное"

class Sentence:
    
    content = [] # не обязательно здесь писать это свойство
    
    def __init__(self, content=content):
        self.content = content
        
    def show(self, words_list):
        result = ''
        for number in self.content:
            result += words_list[number].text + ' '
        return result
    
#    def show_parts(self, words_list):
#        result = ''
#        for number in self.content:
#            result += words_list[number].part + ' '
#        return result

# Исправлено после разбоа д/з:
    def show_parts(self, words_list):
        result = ''
        for number in self.content:
            if words_list[number].part() not in result:
                result += words_list[number].part + ' '
        result = result.rstrip()
        return result


the_dog = Word('собака', 'существительное')
ate = Word('ела', 'глагол')
sausage = Word('колбасу', 'существительное')
in_the_evening = Word('вечером', 'наречие')

words = [the_dog, ate, sausage, in_the_evening]

print([[word.text, word.part] for word in words])
# Вывод вида - "[['собака', 'существительное'], ['ела', 'глагол'], ['колбасу', 'существительное'], ['вечером', 'наречие']]"

content = [0, 2]
my_sentence = Sentence(content)
print(my_sentence.show(words))
# Вывод вида - "собака колбасу"

print(my_sentence.show_parts(words))
# Вывод вида - "существительное существительное"
# Исправлено после разбоа д/з:
# Вывод вида - "существительное"